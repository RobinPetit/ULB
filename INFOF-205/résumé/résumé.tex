\documentclass{article}

\usepackage{palatino, eulervm}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage[bottom]{footmisc}
\usepackage[parfill]{parskip}
\usepackage{mathtools}
\usepackage{mathdots}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{commath}
\usepackage{hyperref}

\makeatletter
\def\thm@space@setup{
	\thm@preskip=.4cm%
	\thm@postskip=\thm@preskip%
}
\makeatother

%amsthm
\newtheorem{thm}{Théorème}[section]
\newtheorem{prp}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemme}
\newtheorem{cor}[thm]{Corollaire}
\renewcommand{\proofname}{\it{Preuve}}
\theoremstyle{definition}
\newtheorem{déf}[thm]{Définition}
\theoremstyle{remark}
\newtheorem*{rmq}{Remarque}
\newtheorem{ex}{Exemple}

\DeclareMathOperator{\Jac}{Jac}
\DeclareMathOperator{\tq}{t.q.}

\newcommand{\C}{\mathbb C}
\newcommand{\F}{\mathbb F}
\newcommand{\N}{\mathbb N}
\newcommand{\Q}{\mathbb Q}
\newcommand{\R}{\mathbb R}

\newcommand{\kappaabs}{\kappa_{\text{abs}}}
\newcommand{\algonum}[3]{F_{#1}(#2^{(#1)}, #3^{(#1)})}
\newcommand{\algnum}{\algonum nxd}

\author{R. Petit}
\date{Année académique 2015 - 2016}
\title{INFOF-205 : Calcul formel et numérique}

\begin{document}
\pagenumbering{Roman}
\maketitle
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}
	\begin{déf} Le \emph{calcul numérique} est une discipline qui traite de la définition, l'analyse, et l'implémentation d'algorithmes pour la résolution
	numérique des problèmes mathématiques qui proviennent de la modélisation des phénomènes réels.\footnote{Nick Trefehen, Oxford.}
	\end{déf}

	Le calcul numérique représente donc le triplet (modèle analytique, solution théorique, résolution algorithmique).

	\begin{rmq} Le calcul numérique étant une application informatique pour la résolution de problèmes mathématiques continus, plusieurs types de problèmes
	peuvent arriver (section suivante). Afin de limiter les problèmes de précision sur des fonctions continues compliquées à évaluer précisément informatiquement,
	plusieurs outils d'approximation peuvent être utilisés. Le théorème de Taylor permet d'approcher certaines fonctions de manière plus facilement calculatoires
	de manière informatique.
	\end{rmq}

	\begin{thm}[Théorème de Taylor] Soient $f : I \to \R$ où $I$ est un intervalle, $a \in I$ et $k \geq 1$. Alors $T(f, a, k)(x)$ est le seul polynôme de
	degré inférieur ou égal à $k$ tel que~:
	\[\lim_{x \to a}\frac {f(x)-T(f, a, k)}{(x-a)^k} = 0,\]
	où $T(f, a, k)(x)$, appelé \emph{polynôme de Taylor} est défini par~:
	\[T(f, a, k)(x) = \sum_{i=0}^k\frac {f^{(i)}(a)(x-a)^i}{i!}.\]
	\end{thm}

	Le calcul numérique est défini comme étant une application informatique à des problèmes relatifs à des phénomènes réels. Bien souvent, ces phénomènes
	sont modélisés de manière \emph{continue}. Les ordinateurs quant à eux sont \emph{discrets}. Cette différence majeure force des approximations par le matériel
	informatique. Les transformations discrètes (\emph{discrétisations}) des phénomènes réels doivent alors être rigoureusement analysés afin de déterminer leur
	robustesse et leur fiabilité.

	Les problèmes peuvent être classifiés de plusieurs manières selon leurs propriétés et ce qui en est attendu.

	\begin{déf} Un problème est dit~:
	\begin{itemize}
		\item \emph{qualitatif} lorsque le comportement des solutions est étudié afin d'en déterminer sa stabilité, son comportement asymptotique~;
		\item \emph{quantitatif} lorsque la solution (numérique) précise est étudiée afin de tirer des conclusions spécifiques.
	\end{itemize}
	\end{déf}

	Un problème qualitatif cherche des conclusions globales à un problème (étude d'une famille de problèmes) et un problème quantitatif est une application
	précise appliquée à un problème donné.

	\begin{déf} Un problème est dit sous forme~:
	\begin{itemize}
		\item \emph{explicite} quand la solution $x$ d'un problème est une fonction donnée des données $d$~;
		\item \emph{implicite} quand la solution ne peut être extraite explicitement des données.
	\end{itemize}
	\end{déf}

	\begin{ex} \emph{Trouver la racine carrée d'un nombre $d \in \R$} est un problème explicite que l'on peut écrire $x = f(d) = \sqrt d$.

	\emph{Déterminer l'ensemble des solutions $x$ à l'équation $ax^2 + bx + c$} est un problème implicite car la solution n'est pas séparée explicitement des
	données. On peut tout de même exprimer ce problème implicite comme~:
	\[X = \left\{\frac {-b \pm \sqrt {b^2-4ac}}{2a}\right\},\]
	qui est un problème explicite.
	\end{ex}

	\begin{rmq} La forme générale d'un problème explicite est $x = F(d)$, alors que la forme générale d'un problème implicite est $F(x, d) = 0$. \end{rmq}

	\begin{déf} Le problème explicite $x = F(d)$ est dit \emph{bien posé} si la solution $x$~:
	\begin{enumerate}
		\item existe~;
		\item est unique~;
		\item dépend \textbf{continument} de $d$.
	\end{enumerate}

	Si un problème n'est pas bien posé, on dit qu'il est \emph{mal posé}.
	\end{déf}

	\begin{déf} Un problème est dit \emph{problème inverse} s'il correspond à la détermination des données d'entrée $x$ d'une application $G$ en connaissant
	les données de sortie $G(x) \eqqcolon d$.
	\end{déf}

	\begin{rmq} Les problèmes inverses sont de manière générale mal posés, entre autre parce qu'il est fréquent que l'application $G$ ne soit pas injective
	et donc que plusieurs données $x$ peuvent donner la même donnée $d = G(x)$.
	\end{rmq}

	\begin{rmq} Ce cours ne traitera que de problèmes bien posés. \end{rmq}

	\begin{déf}~
	\begin{itemize}
		\item Le \emph{conditionnement} d'un problème $x = F(d)$ bien posé est la mesure de la \emph{sensibilité} de $x$ à des petits changements sur $d$.
		\item On définit par $\delta d$ une faible perturbation (également dite \emph{perturbation admissible}) sur la donnée $d$. On définit alors la
		      perturbation induite sur $x$ par $\delta x = F(d + \delta d) - F(d)$.
		\item Le \emph{conditionnement relatif} du problème est la quantité~:
		      \[\kappa(d) \coloneqq \lim_{\abs D \to 0}\sup_{\delta d \in D} \frac {\norm {\delta x}\norm d}{\norm x\norm{\delta d}}
			  = \lim_{\abs D \to 0}\sup_{\delta \in D}\frac {\norm {F(d + \delta d) - F(d)}\norm d}{\norm {F(d)}\norm {\delta d}},\]
		      où $D$ est un voisinage de l'origine, et $\sup$ désigne la borne supérieure.
	\end{itemize}
	\end{déf}

	\begin{rmq}~
	\begin{itemize}
		\item si $x = 0$, alors le conditionnement relatif est forcément infini~;
		\item si $d = 0$, alors le conditionnement relatif est forcément nul~;
		\item quand $0 \in \{x, d\}$, il faut définir une autre notion, le conditionnement absolu~:
		      \[\kappaabs(d) \coloneqq \lim_{\abs D \to 0}\sup_{\delta d \in D}\frac {\norm {\delta x}}{\norm {\delta d}}.\]
	\end{itemize}
	\end{rmq}

	\begin{prp} Si $x = F(d)$ est un problème explicite, et $F$ est une fonction différentiable en $d$, alors, par définition~:
	\[\lim_{\delta \to 0}\frac {\delta x}{\delta d}\]
	ne dépend pas de la trajectoire de $\delta d$ vers $0$. On note alors~:
	\[F'(d) = \lim_{\delta d \to 0}\frac {\delta x}{\delta d},\]
	et on réécrit le conditionnement par~:
	\[\kappa(d) = \lim_{\delta d \to 0}\frac {\norm {\delta x}d}{\norm {\delta d}x}
	= \frac {\norm d}{\norm x}\lim_{\delta d \to 0}\frac {\norm {\delta x}}{\norm {\delta d}} = \norm {F'(d)}\frac {\norm  d}{\norm x}.\]
	\end{prp}

	\begin{rmq} Si $d \in \R^m$, et $x \in \R^n$, alors $F'(d)$ est la matrice jacobienne $(\Jac F)(d)$. Et si $q = 1$, la matrice jacobienne n'a qu'une seule
	ligne et on parle du gradient $(\nabla F)(d)$
	\end{rmq}

	\begin{ex}[Conditionnement d'une différence] Soit le problème $x = F(d) = d-a$. La fonction $F$ est différentiable, on peut donc déterminer le
	conditionnement~:
	\[\kappa(d) = \norm {F'(d)}\frac {\norm d}{\norm x} = 1\frac {\norm d}{\norm {d-a}}.\]
	On voit alors que le conditionnement est petit pour $\norm {d-a} >> 0$. Cependant, pour $d$ proche de $a$, le conditionnement devient très grand.
	Le problème est donc \emph{mal conditionné} pour $d$ proche de $a$.
	\end{ex}

	\begin{ex}[Conditionnement d'une exponentiation] Soit le problème $x = F(d) = d^r$ avec $r \in \R$. À nouveau, $F$ est différentiable, et donc on peut
	exprimer le conditionnement comme~:
	\[\kappa(d) = \norm {F'(d)}\frac {\norm d}{\norm x} = \norm r\norm {d^{r-1}}\frac {\norm d}{\norm {d^r}} = \norm r.\]
	Le conditionnement dépend donc de l'exposant $r$. Si $r$ est grand, le problème est mal conditionné, peu importe la valeur de $d$.
	\end{ex}

	Le conditionnement d'un problème est une caractéristique qui lui est intrinsèque. Si un problème est mal conditionné, peu importe l'algorithme utilisé pour
	le résoudre, la solution restera fortement influencé par des perturbations sur les données $d$. De plus, plus un problème a un grand conditionnement, plus
	il sera difficile à résoudre numériquement.

	\begin{rmq} les exemples ci-dessus montrent qu'un problème peut avoir un conditionnement faible pour certaines valeurs de $d$ et un conditionnement élevé
	pour d'autres valeurs.
	\end{rmq}

	Soit $F(x, d) = g(x) - d = 0$, un problème implicite. Prenons $g : \R \to \R$ une fonction réelle différentiable. On peut alors exprimer $x = g^{-1}(d)$.
	Donc le conditionnement vaut~:
	\[\kappa(d) = \abs {\frac {(g^{-1})'(d)d}{g^{-1}(d)}} = \abs {\frac 1{g'(g^{-1}(d))}}\abs{\frac d{g^{-1}(d)}} = \abs {\frac 1{g'(x)}}\abs{\frac dx}.\]
	On remarque donc que pour $g'(x)$ petit le conditionnement devient grand. C'est intuitivement lié au fait qu'une fonction à faible dérivée (pente) en $d$
	va croitre lentement et donc pour une faible perturbation sur $d$ (axe vertical), une grande perturbation sur $x$ (axe horizontal) va être induite.

	\begin{déf} Soit $F(x, d) = 0$ un problème bien posé. On définit l'\emph{algorithme numérique} pour la résolution du problème $F$ par la suite de problèmes
	approchés $\algonum 1xd, \algonum 2xd, \dotsc, \algnum$ dépendant d'un paramètre $n$.
	\end{déf}

	L'idée derrière la division en sous-problèmes est d'avoir des $F_k$ plus simples à résoudre que $F$, ce qui permet une résolution numérique.

	\begin{déf} Un algorithme numérique est dit~:
	\begin{itemize}
		\item \emph{direct} si le nombre $n$ de sous-problèmes est fixé (du moins majoré), habituellement par une fonction de la taille du problème~;
		\item \emph{itératif} si $n$ n'est pas borné et s'il existe une routine $f(u)$ admissible, indépendante de $n$ telle que $x^{(n)} = f(x^{(n-1)})$.
	\end{itemize}
	\end{déf}

	\begin{déf} Un algorithme numérique $\{\algonum ixd\}_{1 \leq i \leq n}$ est consistant si~:
	\[\lim_{n \to +\infty}\algnum = F(x, d^{(n)}),\]
	et donc si $x$, la solution précise, est une solution ses sous-problèmes pour $n \to +\infty$.
	\end{déf}

	\begin{rmq} Un algorithme itératif $x^{(n)} = f(x^{(n-1)})$ est consistant si $x^{(n)} = x$ implique que $x^{(n+1)} = x$. Ce qui revient à dire qu'une fois
	la solution exacte atteinte, l'algorithme itératif la conserve et ne diverge pas.
	\end{rmq}

	\begin{déf} Un algorithme $\algnum$ est dit \emph{fortement} consistant si~:
	\[\forall n \geq 1 : F_n(x, d^{(d)}) = 0,\]
	c'es-tà-dire si $x$ est une solution admissible de tous les sous-problèmes $\algnum$.
	\end{déf}

	Intéressons-nous au problème $F(x, d)$ et à $\algnum$, un algorithme numérique de résolution du problème. Supposons que cet algorithme numérique soit composé
	d'étapes telles que~:
	\[x^{(n)} = F_n^{(m)}\left(d_{m-1}^{(n)}\right),\]
	où~:
	\[d_{k}^{(n)} = F_n^{(k)}\left(d_{k-1}^{(n)}\right)\qquad\qquad\text{ et }\qquad\qquad d_0^{(n)} = d^{(n)}.\]

	On considère que la résolution numérique est l'application de cet algorithme sur des valeurs perturbées~:
	\[\begin{cases}
		\bar x^{(n)} &= F_m^{(n)}\left(\bar d_{m-1}^{(n)}\right) + \delta d_m^{(n)} \\
		\bar d_k^{(n)} &= F_{k}^{(n)}\left(\bar d_{k-1}^{(n)}\right) + \delta d_k^{(n)} \\
		\bar d_0^{(n)} &= d^{(n)}
	\end{cases}\]

	\begin{rmq} On voit bien que l'algorithme à l'étape $n$ commence avec $\bar d_0^{(n)} = d^{(n)}$ qui est une donnée initiale \emph{non perturbée}. \end{rmq}

	\begin{déf} Soit $\algnum$ un algorithme numérique. On dit qu'il est \emph{stable} (ou \emph{bien posé}) si~:
	\begin{itemize}
		\item $\forall n : \exists! x^{(n)}$, solution~;
		\item \[\forall \epsilon > 0 : \exists \eta > 0, n_0 \in \N^* \tq \forall n > n_0 :
			\left(\forall i \in \{1, \dotsc, m\} : \norm {\delta d_i^{(n)}} < \eta\right) \Rightarrow \left(\norm {\bar x^{(n)}-x^{(n)}} < \epsilon\right).\]
	\end{itemize}
	\end{déf}

	\begin{déf} Si l'opération $F_m^{(n)}(d)$ ne dépend ni de $m$, ni de $n$, on parle d'algorithme \emph{itératif}. \end{déf}

	\begin{rmq} Un algorithme est donc dit itératif si c'est constamment la même opération qui est appliquée sur des données consécutives. On a alors~:
	\[x^{(n)} = f(x^{(n-1)}) = (f \circ f)(x^{(n-2)}) = \dotsb = \left(f^n\right)(x^{(0)}) = \left(f^n\right)(d).\]
	\end{rmq}

	On peut traduire la définition de stabilité de manière plus informelle par le fait qu'un algorithme est stable s'il existe un voisinage de $x$, la solution
	tel que pour tout $x_1, x_2$ dans ce voisinage, on a un $R \in (0, 1)$ tel que~:
	\[\norm {f(x_2)-f(x_1)} \leq R\norm {x_2-x_1}.\]
	Si $f$ est une fonction différentiable, alors on peut dire que~:
	\[\norm {f'(x_2)} \leq R.\]

\newpage
\section{Analyse et mesure d'erreurs}
	\subsection{Définitions}
		\begin{déf} $\F$ est l'ensemble des nombres représentés exactement par un ordinateur. \end{déf}

		\begin{rmq} On remarque aisément que $\F \subset \R$ car $\F \not \subset \C \setminus \R$. On peut tout de même raffiner car il semble évident que
		$\F \subset \Q$~: un nombre irrationnel n'a pas de représentation physique finie, et ne peut donc pas être représentés par un ordinateur.
		\end{rmq}

		\begin{déf} Soit $x$ un nombre dans $\Q$. Une approximation de $x$ est une valeur $\widehat x$ légèrement différente de $x$ et qui remplace $x$ dans les
		calculs effectués. On note également $x \simeq \widehat x$ pour montrer que $\widehat x$ est une approximation de $x$.

		Si $\widehat x < x$, on parle d'approximation par défaut, et si $\widehat x > x$, on parle d'approximation par excès.
		\end{déf}

		\begin{déf} On définit l'\emph{erreur absolue} entre $x$ et son approximation $\widehat x$ par~:
		\[\delta_x = \abs {\widehat x - x}.\]

		On définit également l'\emph{écart relatif} entre $x$ et $\widehat x$ par~:
		\[\rho_x = \frac {\widehat x - x}x.\]

		On définit alors l'écart absolue défini comme $\epsilon_x = \abs {\rho_x}$.
		\end{déf}

		\begin{rmq} L'écart relatif permet d'écrire l'approximation sous la forme $\widehat x = x(1+\rho_x)$ où $\rho_x$ est censé être faible (car l'écart
		entre $x$ et son approximation doit rester relativement faible). Cette notation est fortement utilisée.

		Les écarts ne sont cependant définis qu'en $x \neq 0$, ce dont il faut tenir compte.
		\end{rmq}

		\begin{déf} La \emph{borne supérieure d'erreur relative} d'une approximation $\widehat x$, notée $u$ est nombre positif quelconque tel que
		$u \geq \epsilon_x$.
		\end{déf}

		Mis à part les erreurs de calcul (qui consistent à déterminer un résultat erroné sur base de données bien définies) et les erreurs d'implémentation
		(qui consiste en une implémentation erronée amenant à des erreurs de calcul), il existe cinq catégories d'erreurs que l'on peut regrouper en deux
		familles~:

		\begin{itemize}
			\item les erreurs de modèle qui consistent en simplifier les phénomènes en omettant des éléments afin de le rendre plus facile à étudier~;
			\item les erreurs numériques qui consistent en l'approximation due à l'observation et non à la résolution théorique.
		\end{itemize}

	\subsection[les erreurs numériques]{Les erreurs numériques\footnote{Les erreurs de modélisation ne sont pas traitées ici.}}
		\begin{déf} Les \emph{erreurs de troncature} sont les erreurs liées aux processus théoriques mathématiques infinis (série infinie par exemple).
		\end{déf}

		\begin{déf} Les \emph{erreurs d'arrondi} sont les erreurs liées au système numérique de la machine venant du fait qu'un ordinateur ne peut représenter
		qu'un sous-ensemble fini $\F$ des nombres.
		\end{déf}

		\begin{déf} Les \emph{erreurs de génération et de propagation} sont les erreurs liées à l'évaluation d'une opération sur des opérandes pas exactes.
		\end{déf}

		\begin{rmq} Les erreurs de troncature sont compliquées à éviter~: il est nécessaire d'avoir un procédé fini pour y échapper. Cette catégorie d'erreurs
		ne seront donc pas étudiées dans ce cours.
		\end{rmq}

		Les différents types d'erreurs concernent différentes propriétés des problèmes ou des algorithmes numériques utilisés.

		\begin{prp}~
		\begin{itemize}
			\item Les erreurs d'approximation ou de troncature se mesurent par la \textbf{consistance} de l'algorithme~;
			\item les erreurs de propagation se mesurent par le \textbf{conditionnement} de l'algorithme~;
			\item les erreurs de génération se mesurent par la \textbf{stabilité de l'algorithme}~;
			\item les erreurs d'arrondi sont liées à la représentation interne des nombres.
		\end{itemize}
		\end{prp}

	\subsection{Représentation interne des nombres par l'ordinateur}

\end{document}
